//* IMPORTS
const gridSizeInput = document.getElementById("grid-size");
const gridSizeLabel = document.getElementById("grid-size-label");

const computerSpeedInput = document.getElementById("computer-speed");
const computerSpeedTitle = document.getElementById("computer-speed-title");
const computerSpeedLabel = document.getElementById("computer-speed-label");

const patternLengthInput = document.getElementById("pattern-length");
const patternLengthTitle = document.getElementById("pattern-length-title");
const patternLengthLabel = document.getElementById("pattern-length-label");

const gameScores = document.getElementById("game-scores");
const gameScoresTitle = document.getElementById("game-scores-title");

const scrollTopButton = document.getElementById("scroll-top");

const startGameButton = document.getElementById("start-game");
const timerLabel = document.getElementById("timer");

const gameContainer = document.getElementById("game-container");

const computerGridContainer = document.getElementById(
  "computer-grid-container"
);
const userGridContainer = document.getElementById("user-grid-container");

//! Set Grid Container Style
const computerGridContainerStyle = computerGridContainer.style;
computerGridContainerStyle.display = "grid";
const userGridContainerStyle = userGridContainer.style;
userGridContainerStyle.display = "grid";

//! Modal Parts
const modal = {
  modal: document.getElementById("game-modal"),
  show: () => $("#game-modal").modal(),
  title: document.getElementById("game-modal-title"),
  body: document.getElementById("game-modal-body"),
};

const BOX_SIZE = 100; // Fixed button size

//! Music and Sounds
const background_music = new Audio("./assets/music/background_music.mp3");
const start_game_sound = new Audio("./assets/music/start_game_sound.mp3");

const countdown_sound = new Audio("./assets/music/countdown.flac");
const lost_sound = new Audio("./assets/music/lost.wav");
const won_sound = new Audio("./assets/music/won.wav");

const button_computer_press_sound = new Audio(
  "./assets/music/button_computer_press.wav"
);
const button_user_press_sound = new Audio(
  "./assets/music/button_user_press.wav"
);

let userGridChildren; // Children of User's Grid

let gameStarted = false; // Game State

let COMPUTER_SEQUENCE = []; // Sequence generated by computer
let USER_SEQUENCE = []; // Sequence user plays

let gridSize = 0; // Size of grid
let computerSpeed = 0; // Speed of computer
let patternLength = 0; // length of pattern

let gameCount = 0; // Game number
let currentPatternNumber = 1; // Current sequence of pattern being displayed

let gameTimer; // Interval for game's timer
let gameTimerCount = 0; // Number of seconds elapsed

/**
 * ? GENERATE GRID COMPONENT
 * * Appends a component to a parent component
 * @param  component Component to generate
 * @param  parentComponent Where to generate the component
 */
const generateGridComponent = (component, parentComponent) => {
  component.style.width = BOX_SIZE;
  component.style.height = BOX_SIZE;
  parentComponent.appendChild(component);
};

/**
 * ? GENERATE BUTTON
 * * Generates a button having different classes, attributes, styles and event on mousedown and mouseup
 * @param classList Classes to add
 * @param attributeList Attributes to add
 * @param mouseDown Function on event mousedown
 * @param mouseUp Function on event mouseup
 * @param styles Styles to add
 */
const generateButton = (
  classList,
  attributeList,
  mouseDown,
  mouseUp,
  styles
) => {
  let button = document.createElement("button");
  if (mouseDown) {
    button.addEventListener("mousedown", mouseDown);
  }

  if (mouseDown) {
    button.addEventListener("mouseup", mouseUp);
  }

  if (classList) {
    if (classList.length > 0) {
      classList.forEach((className) => {
        button.classList.add(className);
      });
    }
  }

  if (attributeList) {
    if (attributeList.length > 0) {
      attributeList.forEach(({ attribute, value }) => {
        button.setAttribute(attribute, value);
      });
    }
  }

  if (styles) {
    if (styles.length > 0) {
      styles.forEach((style) => {
        button.style.setProperty(style.property, style.value);
      });
    }
  }

  return button;
};

/**
 * ? BUILD GRID
 * * Builds the grid for the Computer and the User
 */
const buildGrid = () => {
  if (gridSize && gridSize > 1) {
    resetGrid(); // Clears grid if already built
    let gridCount = gridSize * gridSize; // number of items in grid
    let repeatCSS = `repeat(${gridSize}, ${BOX_SIZE}px)`; // css grid template attribute

    computerGridContainerStyle.gridTemplateColumns = repeatCSS;
    computerGridContainerStyle.gridTemplateRows = repeatCSS;

    userGridContainerStyle.gridTemplateColumns = repeatCSS;
    userGridContainerStyle.gridTemplateRows = repeatCSS;

    if (gridSize >= 2) {
      // Generates the buttons for computer and user and adds it to their grids
      // Repeats for size of grid (e.g. 2x2 = 4 times)
      for (let i = 0; i < gridCount; i++) {
        let computerButton = generateButton(
          ["btn", "btn-primary", "m-1"],
          [
            { attribute: "id", value: `comp-${i}` },
            { attribute: "disabled", value: true },
          ]
        );
        let userButton = generateButton(
          ["btn", "m-1"],
          [{ attribute: "id", value: `user-${i}` }],
          () => {
            userButtonOnMouseDown(i);
          },
          () => {
            userButtonOnMouseUp(i);
          },
          [
            { property: "background-color", value: "#686868" },
            {
              property: "box-shadow",
              value: "0px 0px 10px 0px rgba(0, 0, 0, 0.2)",
            },
          ]
        );

        generateGridComponent(computerButton, computerGridContainer);
        generateGridComponent(userButton, userGridContainer);
      }
    }
    return true;
  } else {
    return false;
  }
};

/**
 * ? RESET GRID
 * * Resets the grid generated
 */
const resetGrid = () => {
  computerGridContainerStyle.removeProperty("grid-template-columns");
  computerGridContainerStyle.removeProperty("grid-template-rows");
  userGridContainerStyle.removeProperty("grid-template-columns");
  userGridContainerStyle.removeProperty("grid-template-rows");
  computerGridContainer.textContent = "";
  userGridContainer.textContent = "";
};

/**
 * ? RESET GAME
 * * Cleanup code to reset game states
 */
const resetGame = () => {
  setGridSize();
  setComputerSpeed();
  setPatternLength();
  currentPatternNumber = 1;

  COMPUTER_SEQUENCE = [];
  USER_SEQUENCE = [];

  gridSizeInput.removeAttribute("disabled");
  computerSpeedInput.removeAttribute("disabled");
  patternLengthInput.removeAttribute("disabled");

  startGameButton.style.visibility = "visible";
  startGameButton.removeAttribute("disabled");

  timerLabel.style.visibility = "hidden";

  resetGrid();
};

/**
 * ? SET GRID SIZE
 * * Sets the Grid Size for slider
 */
const setGridSize = () => {
  gridSize = gridSizeInput.value;
  gridSizeLabel.innerText = `${gridSize} x ${gridSize}`;
};

/**
 * ? SET COMPUTER SPEED
 * * Sets the computer speed from slider
 * * Changes speed label to red when > 5
 */
const setComputerSpeed = () => {
  computerSpeed = computerSpeedInput.value;
  computerSpeedLabel.innerText = computerSpeed - 1;
  if (computerSpeed > 5) {
    computerSpeedLabel.classList.add("text-danger");
    computerSpeedTitle.classList.add("text-danger");
  } else {
    computerSpeedLabel.classList.remove("text-danger");
    computerSpeedTitle.classList.remove("text-danger");
  }
};

/**
 * ? SET PATTERN LENGTH
 * * Sets the pattern length from slider
 * * Changes pattern label to red when > 5
 */
const setPatternLength = () => {
  patternLength = patternLengthInput.value;
  patternLengthLabel.innerText = patternLength;
  if (patternLength > 5) {
    patternLengthLabel.classList.add("text-danger");
    patternLengthTitle.classList.add("text-danger");
  } else {
    patternLengthLabel.classList.remove("text-danger");
    patternLengthTitle.classList.remove("text-danger");
  }
};

/**
 * ? COUNTDOWN
 * * Counts down from a specified number of seconds
 * @param timerCount Amount of seconds to countdown from
 */
const countDown = (timerCount) => {
  return new Promise((res, rej) => {
    let timer = setInterval(() => {
      if (timerCount < 0) {
        clearInterval(timer);
        res();
      } else {
        countdown_sound.play();
        timerLabel.innerText = timerCount.toString();
      }
      timerCount--;
    }, 1000);
  });
};

/**
 * ? GENERATE COMPUTER PATTERN
 * * Randomly generates the computer pattern depending on the grid size chosen
 */
const generateComputerPattern = () => {
  let tempFinalPattern = [];
  // Generate final pattern
  for (let i = 0; i < patternLength; i++) {
    let index = Math.floor(Math.random() * (gridSize * gridSize));
    tempFinalPattern.push(index);
  }
  // Generate sequence
  for (let i = 0; i < patternLength; i++) {
    COMPUTER_SEQUENCE[i] = [];
    tempFinalPattern.forEach((item) => COMPUTER_SEQUENCE[i].push(item));
    tempFinalPattern.pop();
  }
  COMPUTER_SEQUENCE.reverse(); // Computer Sequence Set
  console.log("CHEAT SEQUENCE" + "\n" + COMPUTER_SEQUENCE);
  return true;
};

/**
 * ? LIGHT COMPUTER BUTTON
 * * Lights the computer grid button specified by the id
 * @param id ID if button to light up
 */
const lightComputerButton = (id) => {
  return new Promise((res, rej) => {
    let button = document.getElementById(`comp-${id}`);
    button_computer_press_sound.play();

    button.classList.remove("btn-primary");
    button.classList.add("btn-danger");

    setTimeout(() => {
      button.classList.remove("btn-danger");
      button.classList.add("btn-primary");
      setTimeout(() => res(), 1000 / computerSpeed);
    }, 1000 / computerSpeed);
  });
};

/**
 * ? USE BUTTON MOUSE DOWN
 * * Function to be executed on mouse down on user button
 * @param id ID of the button
 */
const userButtonOnMouseDown = (id) => {
  let button = document.getElementById(`user-${id}`); // Get button
  button.style.backgroundColor = "#525050"; // Change button color
  button_user_press_sound.play(); // Play sound
};

/**
 * ? USER BUTTON MOUSE UP
 * * Function to be executed on mouse up on user button
 * @param id
 */
const userButtonOnMouseUp = (id) => {
  let button = document.getElementById(`user-${id}`); // Get button
  button.style.backgroundColor = "#686868"; // Change button color
  for (let i = 0; i < currentPatternNumber; i++) {
    if (!USER_SEQUENCE[i]) {
      USER_SEQUENCE[i] = [];
      USER_SEQUENCE[i].push(id);
    } else {
      USER_SEQUENCE[i].push(id);
    }
  }
  check(); // Check if pattern matches
};

/**
 * ? START GAME TIMER COUNTER
 * * Starts the game timer and updates it on the screen
 */
const startGameTimerCounter = () => {
  gameTimer = setInterval(() => {
    timerLabel.innerText = `Time Elapsed: ${gameTimerCount} s`;
    gameTimerCount++;
  }, 1000);
};

/**
 * ? STOP GAME TIMER COUNTER
 * * Stops the game timer
 */
const stopGameTimerCounter = () => {
  gameTimerCount = 0;
  clearInterval(gameTimer);
};

/**
 * ? START GAME
 * * Starts the game
 * * Counts down > Builds Grid > Generates Computer Pattern > Light up first button
 */
const startGame = () => {
  gameContainer.scrollIntoView();
  gameCount++;
  gameStarted = true;
  gridSizeInput.setAttribute("disabled", true);
  computerSpeedInput.setAttribute("disabled", true);
  patternLengthInput.setAttribute("disabled", true);

  startGameButton.style.visibility = "hidden";
  startGameButton.setAttribute("disabled", true);

  timerLabel.style.visibility = "visible";

  countDown(5).then(() => {
    start_game_sound.play().then(() => {
      const gridBuilt = buildGrid();
      if (gridBuilt) {
        userGridChildren = userGridContainer.children;
        // Start Game Logic
        timerLabel.innerText = "Started";
        setTimeout(async () => {
          // Start Pattern
          const generatedComputerPattern = generateComputerPattern();
          if (generatedComputerPattern) {
            startGameTimerCounter();
            for (let i = 0; i < userGridChildren.length; i++) {
              userGridChildren[i].setAttribute("disabled", true);
            }
            await lightComputerButton(COMPUTER_SEQUENCE[0][0]);
            for (let i = 0; i < userGridChildren.length; i++) {
              userGridChildren[i].removeAttribute("disabled");
            }
          }
        }, 2000);
      }
    });
  });
};

/**
 * ? SHOW MODAL
 * * Shows a modal
 * @param title Modal title
 * @param body Modal Body
 */
const showModal = (title, body) => {
  modal.title.innerText = title;
  modal.body.innerText = body;

  modal.show();
};

/**
 * ? UPDATE GAME SCORE
 * * After a game, a card is added to the scoreboard with the user's score
 * @param didWin Did user win?
 */
const updateGameScore = (didWin) => {
  let row = document.createElement("div");
  row.classList.add("row", "py-3", "my-3", "mx-3");
  row.style.borderRadius = "30px";
  row.style.backgroundColor = "#5f5a7a";
  row.style.border = "yellow 10px solid";

  let countDiv = document.createElement("div");
  countDiv.classList.add(
    "col-2",
    "d-flex",
    "justify-content-center",
    "align-items-center"
  );
  let countH2 = document.createElement("h2");
  countH2.classList.add("text-white");
  countH2.innerText = gameCount;

  let gameDetailDiv = document.createElement("div");
  gameDetailDiv.classList.add("col-10");
  let gameDetailRow = document.createElement("div");
  gameDetailRow.classList.add("row");

  let gameStatusDiv = document.createElement("div");
  gameStatusDiv.classList.add(
    "col",
    "d-flex",
    "justify-content-center",
    "align-items-center"
  );
  let gameStatusH2 = document.createElement("h2");
  gameStatusH2.classList.add(didWin ? "text-success" : "text-danger");
  gameStatusH2.innerText = didWin ? "WON" : "LOST";

  let gameSettingsDiv = document.createElement("div");
  gameSettingsDiv.classList.add("col");
  let gameSettingsH5 = document.createElement("h5");
  gameSettingsH5.classList.add("text-white");
  gameSettingsH5.innerText = `Game Settings âš™ \n Grid Size: ${gridSize} \n Speed: ${computerSpeed} \n Pattern Length: ${patternLength} \n Time Taken: ${gameTimerCount}s`;

  //! Append
  countDiv.append(countH2);

  gameStatusDiv.appendChild(gameStatusH2);
  gameSettingsDiv.appendChild(gameSettingsH5);

  gameDetailRow.appendChild(gameStatusDiv);
  gameDetailRow.appendChild(gameSettingsDiv);

  gameDetailDiv.appendChild(gameDetailRow);

  row.appendChild(countDiv);
  row.appendChild(gameDetailDiv);
  gameScores.insertBefore(row, gameScores.firstChild);
};

/**
 * ? CHECK WITH PREVIOUS
 * * Checks the current user button press sequence with the previous computer sequence
 */
const checkWithPrevious = () => {
  let valid = false;
  if (currentPatternNumber === 1) {
    if (
      USER_SEQUENCE[currentPatternNumber - 1][0] ===
      COMPUTER_SEQUENCE[currentPatternNumber - 1][0]
    ) {
      valid = true;
    } else {
      valid = false;
    }
  } else {
    for (let i = 0; i < USER_SEQUENCE[currentPatternNumber - 1].length; i++) {
      if (
        USER_SEQUENCE[currentPatternNumber - 1][i] ===
        COMPUTER_SEQUENCE[currentPatternNumber - 1][i]
      ) {
        valid = true;
      } else {
        valid = false;
      }
    }
  }

  return valid;
};

/**
 * ? CHECK
 * * Checks the pattern the user pressed with the computer's pattern
 */
const check = () => {
  // Check previous patterns
  let checked = checkWithPrevious();

  if (checked) {
    // Same length?
    if (
      USER_SEQUENCE[currentPatternNumber - 1].length === currentPatternNumber
    ) {
      let strComputerSequence = JSON.stringify(
        COMPUTER_SEQUENCE[currentPatternNumber - 1]
      );
      let strUserSequence = JSON.stringify(
        USER_SEQUENCE[currentPatternNumber - 1]
      );

      if (strComputerSequence === strUserSequence) {
        // Pattern Matches
        currentPatternNumber++;
        if (currentPatternNumber <= patternLength) {
          setTimeout(async () => {
            for (
              let i = 0;
              i < COMPUTER_SEQUENCE[currentPatternNumber - 1].length;
              i++
            ) {
              for (let i = 0; i < userGridChildren.length; i++) {
                userGridChildren[i].setAttribute("disabled", true);
              }
              await lightComputerButton(
                COMPUTER_SEQUENCE[currentPatternNumber - 1][i]
              );
              for (let i = 0; i < userGridChildren.length; i++) {
                userGridChildren[i].removeAttribute("disabled");
              }
            }
          }, 1000 / computerSpeed);
        } else {
          gameStarted = false;
          showModal(
            "ðŸ”¥ You Won ðŸ”¥",
            `Mission Accomplished Soldier \n\n Game Settings âš™ \n Grid Size: ${gridSize} \n Speed: ${computerSpeed} \n Pattern Length: ${patternLength} \n Time Taken: ${gameTimerCount}s`
          );
          updateGameScore(true);
          won_sound.play(); // Win sound
          gameScoresTitle.scrollIntoView(); // Scroll to scoreboard
          resetGame();
          stopGameTimerCounter();
          return;
        }
      } else {
        gameStarted = false;
        howModal(
          "ðŸ’¥ You Lost ðŸ’¥",
          `Mission Failed, We'll Get Em' Next Time \n\n Grid Size: ${gridSize} \n Speed: ${computerSpeed} \n Pattern Length: ${patternLength} \n Time Taken: ${gameTimerCount}s`
        );
        updateGameScore(false);
        lost_sound.play(); // Loss sound
        gameScoresTitle.scrollIntoView(); // Scroll to scoreboard
        resetGame();
        stopGameTimerCounter();
        return;
      }
    }
  } else {
    gameStarted = false;
    showModal(
      "ðŸ’¥ You Lost ðŸ’¥",
      `Mission Failed, We'll Get Em' Next Time \n\n Grid Size: ${gridSize} \n Speed: ${computerSpeed} \n Pattern Length: ${patternLength} \n Time Taken: ${gameTimerCount}s`
    );
    updateGameScore(false);
    lost_sound.play(); // Loss sound
    gameScoresTitle.scrollIntoView(); // Scroll to scoreboard
    resetGame();
    stopGameTimerCounter();
    return;
  }
};

gridSizeInput.addEventListener("input", setGridSize);
computerSpeedInput.addEventListener("input", setComputerSpeed);
patternLengthInput.addEventListener("input", setPatternLength);

startGameButton.addEventListener("click", startGame);
scrollTopButton.addEventListener("click", () => scrollTo({ top }));

document.addEventListener("keydown", (e) => {
  switch (e.key) {
    case "q":
      userButtonOnMouseDown(0);
      break;
    case "w":
      userButtonOnMouseDown(1);
      break;
    case "e":
      userButtonOnMouseDown(2);
      break;
    case "r":
      userButtonOnMouseDown(3);
      break;
    case "t":
      userButtonOnMouseDown(4);
      break;
    case "y":
      userButtonOnMouseDown(5);
      break;
    case "u":
      userButtonOnMouseDown(6);
      break;
    case "i":
      userButtonOnMouseDown(7);
      break;
    case "o":
      userButtonOnMouseDown(8);
      break;
    case "p":
      userButtonOnMouseDown(9);
      break;
    case "a":
      userButtonOnMouseDown(10);
      break;
    case "s":
      userButtonOnMouseDown(11);
      break;
    case "d":
      userButtonOnMouseDown(12);
      break;
    case "f":
      userButtonOnMouseDown(13);
      break;
    case "g":
      userButtonOnMouseDown(14);
      break;
    case "h":
      userButtonOnMouseDown(15);
      break;
    case "j":
      userButtonOnMouseDown(16);
      break;
    case "k":
      userButtonOnMouseDown(17);
      break;
    case "l":
      userButtonOnMouseDown(18);
      break;
    case "z":
      userButtonOnMouseDown(19);
      break;
    case "x":
      userButtonOnMouseDown(20);
      break;
    case "c":
      userButtonOnMouseDown(21);
      break;
    case "v":
      userButtonOnMouseDown(22);
      break;
    case "b":
      userButtonOnMouseDown(23);
      break;
    case "n":
      userButtonOnMouseDown(24);
      break;
    default:
      break;
  }
});

document.addEventListener("keyup", (e) => {
  if (e.key === "Enter") {
    if (!gameStarted) {
      startGame();
    }
  }
  
  switch (e.key) {
    case "q":
      userButtonOnMouseUp(0);
      break;
    case "w":
      userButtonOnMouseUp(1);
      break;
    case "e":
      userButtonOnMouseUp(2);
      break;
    case "r":
      userButtonOnMouseUp(3);
      break;
    case "t":
      userButtonOnMouseUp(4);
      break;
    case "y":
      userButtonOnMouseUp(5);
      break;
    case "u":
      userButtonOnMouseUp(6);
      break;
    case "i":
      userButtonOnMouseUp(7);
      break;
    case "o":
      userButtonOnMouseUp(8);
      break;
    case "p":
      userButtonOnMouseUp(9);
      break;
    case "a":
      userButtonOnMouseUp(10);
      break;
    case "s":
      userButtonOnMouseUp(11);
      break;
    case "d":
      userButtonOnMouseUp(12);
      break;
    case "f":
      userButtonOnMouseUp(13);
      break;
    case "g":
      userButtonOnMouseUp(14);
      break;
    case "h":
      userButtonOnMouseUp(15);
      break;
    case "j":
      userButtonOnMouseUp(16);
      break;
    case "k":
      userButtonOnMouseUp(17);
      break;
    case "l":
      userButtonOnMouseUp(18);
      break;
    case "z":
      userButtonOnMouseUp(19);
      break;
    case "x":
      userButtonOnMouseUp(20);
      break;
    case "c":
      userButtonOnMouseUp(21);
      break;
    case "v":
      userButtonOnMouseUp(22);
      break;
    case "b":
      userButtonOnMouseUp(23);
      break;
    case "n":
      userButtonOnMouseUp(24);
      break;
    default:
      break;
  }
});

const main = () => {
  resetGame();
  scrollTo({ top });
};

main();
